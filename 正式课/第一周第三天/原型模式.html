<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    /*原型 prototype
     *    1 当我们自定义一个函数（构造函数，类）的时候，有天生自带prototype的属性。并且这个prototype的值也是一个对象类型的。这个对象类型值也有一个天生自带的属性constructor并且属性的值是函数（构造函数，类）本身。
     *    2 这个类的实例也会有一个叫做__proto__的天生自带的属性。并且这个属性的值也是对象类型的。这个值是这个实例所属类的原型
     *    3 每一个引用类型都有一个天生自带的属性__proto__,所以说我们的原型prototype也会天生自带一个__proto__的属性。并且这个属性的值也是一个对象类型，一直到我们的基类Object。
     *    4 通过原型添加的属性和方法都是公有的，每一个实例都会自带
     *    5 一个实例的方法在运行的时候，如果这个方法是私有的就直接用，如果不是私有的通过__proto__去所属类的原型上查找，如果还没有 通过原型的__proto__一直查找到基类的Object。如果没有报错，有就直接用。我们把这种通过__proto__查找的机制叫做【原型链】
     *    6 原型 只能一个一个改 不能一起改
     *    7 链式调用  当调用了一次返回这个类的实例   【注意返回的类型】
     *
     *
     *
     *
     *
     *
     */
  /*  function FE(){}
    console.dir(FE);              //对象 function FE()
    var fe = new FE;             //不传参数 括号可以省略
    console.dir(fe);                //对象 FE
                                   //  FE.prototype.constructor ==  FE;
                                   //  fe.__proto__.constructor ==  FE;
                                   //  fe.__proto__.__proto__   ==  Object.prototype ;
    console.log(Object.prototype);
    console.log( fe.__proto__);*/


   //单独的把原生的覆盖掉了
   /* Array.prototype.push = function () {
        //this 当前的this是实例
        // console.log(this);
        console.log("不能增加了");
    };

    //类上的方法都在实例上 通过__proto__找到prototype
    [1,2,3].push(1);                                     //不能增加了*/


    //防止你修改原型链，一个个改可以，但是不能一起修改
    /*Array.prototype = {
     push: function () {
     console.log("不能增加");
     },
     slice: function () {
     console.log("不能截取");
     }
     }
     [1,2,3].push(0);*/


    function B(){};
    B.prototype = {            //因为指向了一个新的空间，所以没有constructor
        constructor:B,         //我们手动添加
        drink: function () {
            console.log(1);
        },
        eat: function () {
            console.log(2);
        }
    };
    (new B).eat();                           //2
    console.log(new B);                      //对象B


    //  this
    function Fn(){
        this.x = 100;
        this.y = 100;
        this.getY = function (){
            console.log(this.y);}}
    Fn.prototype = {
        constructor : Fn,
        y : 100,
        getX : function (){
            console.log(this.x);
        },
        getY : function (){
            console.log(this.y);}}

    var f = new Fn();
    console.log(f);
    f.getX();                              //100
    f.__proto__.getX();                    //undefined






</script>
</body>
</html>